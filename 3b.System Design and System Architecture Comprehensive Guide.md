# 📘 System Design Overview

## 🔹 What is System Design?

System Design is the process of defining the architecture, components, modules, interfaces, and data for a system to satisfy specified requirements. It involves translating user requirements into a detailed blueprint that guides the implementation phase.

The goal is to create a well-organized and efficient structure that meets the intended purpose while considering factors like scalability, maintainability, and performance.

---

## 🎯 Objectives of System Design

- **Practicality**: Target the intended user base and design accordingly.
- **Accuracy**: Fulfill both functional and non-functional requirements.
- **Completeness**: Meet all user expectations and use cases.
- **Efficiency**: Optimize resource usage to reduce latency and cost.
- **Reliability**: Ensure minimal failure and high uptime.
- **Optimization**: Tune time and space complexity across components.
- **Scalability (Flexibility)**: Adapt to changing user needs over time.
- **Fault Tolerance**: Continue functioning even if one or more components fail.

---

## ✅ Advantages of System Design

- **Reduces Design Cost**: Reuse of patterns and components lowers effort.
- **Accelerates Development**: Frameworks and libraries speed up delivery.
- **Saves Time in SDLC**: Automation and structure reduce iteration cycles.
- **Improves Programmer Efficiency**: Familiar tools and standards reduce errors.
- **Conserves Resources**: Shared workflows prevent duplication.
- **Boosts Developer Creativity**: Encourages synergy across APIs, databases, and protocols.

---

## 🔄 System Design Life Cycle (SDLC)

The SDLC outlines the phases involved in designing and developing a system—software, hardware, or hybrid. It ensures the final product is reliable, scalable, and maintainable.

Phases typically include:
- Requirement Analysis
- System Architecture Design
- Component Design
- Implementation
- Testing
- Deployment
- Maintenance

---

## 🏗️ System Architecture

System Architecture defines how components are structured and deployed. It acts as the skeleton of a software system, laying out abstraction levels and integration points.

In simple terms, it’s the blueprint that aligns business logic with technical execution.

---

## 🧩 System Architecture Patterns

Architecture patterns are predefined ways to organize system components. Each solves specific design challenges.

### Types of Patterns

1. **Client-Server**: Clients request services; servers respond.
2. **Event-Driven**: Components communicate via events for responsiveness.
3. **Microkernel**: Core system with extensible plugins.
4. **Microservices**: Independent services that scale and deploy separately.

---

## 🧱 Modularity and Interfaces

### 1. Modularity
Breaks down systems into independent modules. Each module can be developed and tested separately, improving flexibility and maintainability.

### 2. Interfaces
Defines how users interact with the system—forms, navigation, reports. Good interfaces improve usability and data flow efficiency.

Together, modularity and interfaces create scalable and user-friendly systems.

---

## 📈 Evolution / Upgrade / Scaling of Systems

### 1. Vertical Scaling
Upgrade system specs (RAM, disk, CPU). Improves availability but may not address scalability limits.

### 2. Horizontal Scaling
Connect multiple systems to distribute load. Enhances fault tolerance and scalability.

---

## 🔄 How Data Flows Between Systems

**Data Flow Diagrams (DFDs)** visually represent how data moves through a system.

### DFD Components

| Symbol           | Meaning                                      |
|------------------|----------------------------------------------|
| Square           | Source or destination of data                |
| Arrow            | Data flow pipeline                           |
| Circle/Bubble    | Process transforming input to output         |
| Open Rectangle   | Data store or temporary repository           |

> **Note**: Use uppercase for sender/receiver labels in square boxes as per DFD conventions.

---

## ✈️ System Design Example: Airline Reservation System

### Context-Level Flow

- **Passenger** initiates a travel request.
- **Travel Agent** checks availability and sends a request to the **Airline**.
- If available, a ticket is issued.
- If unavailable, a reservation request is generated.

This flow illustrates how entities interact and how data moves through the system.

---

> 📎 _System Design is not just about structure—it's about creating resilient, scalable, and user-centric solutions._System Architecture Patterns
Modularity and Interfaces In System Design
Modularity and interfaces in systems design are essential concepts that enhance flexibility and usability by breaking down complex systems into manageable components and providing intuitive user interactions.

1. Modularity
Modular design involves breaking down complex products into smaller, independent components or modules. This allows each module (e.g., a car's engine or transmission) to be developed and tested separately, making the overall system more flexible and easier to manage. The final product is assembled by integrating these modules, enabling changes without affecting the entire system.

2. Interfaces
In systems design, interfaces are the points where users interact with the system. This includes navigation elements, data input forms, and report displays. Effective interfaces are intuitive and user-friendly, enhancing the overall user experience and ensuring efficient data collection and system navigation. Together, modularity and well-designed interfaces contribute to creating scalable, maintainable, and user-friendly systems.

Evolution/Upgrade/Scaling of an Existing System
With increasing tech usage, it’s crucial for developers to design scalable systems. If a system is not scalable, it is likely to crash with the increase in users. Hence the concept of scaling comes into effect. Suppose there is a system with configurations of specific disk and RAM which was handling tasks. Now if we need to evolve our system or scale up, we have two options with us.

1. Upgrade Specifications of existing system(Vertical Scaling):
We are simply improving the processor by upgrading the RAM and disk size and many other components. Note that here we are not caring about the scalability and availability of network bandwidth. Here as per evolution we are working over the availability factor only considering scalability will be maintained. This is known as vertical scaling.

2. Create a Distributed System by connecting multiple systems together(Horizontal Scaling):
Horizontal scaling involves connecting multiple systems together to scale up. This method allows for better scalability and fault tolerance by using multiple systems instead of upgrading individual components. In order to scale up, we need more systems (more chunks of blocks) and this is known as horizontal scaling.

Evolution/Upgrade/Scale of an Existing System
Evolution/Upgrade/Scale of an Existing System
How Data Flows Between Systems?
Data Flow Diagrams or DFDs is defined as a graphical representation of the flow of data through information. DFDs are designed to show how a system is divided into smaller portions and to highlight the flow of data between these parts. Below is an example to demonstrate the Data Flow Diagram's basic structure:

Basic-Structure-of-DFD
Basic Stucture of DFD
Components of DFD include:
Representation	Action performed
Square	Defines the source of destination of data
Arrow	Identifies data flow and acts as a pipeline throughwhich information flows
Circle/Bubble	Represents a process that transforms incoming data flow into outgoing data
Open Rectangle	It is a data store or data at rest/temporary repository of data
 Note:  Sender and Receiver should  be written in uppercase always. Rather it is good practrice to use uppercaswe letter what so ever is placed in square box as per DFD conventions. 

System Design Example: Airline Reservation System
Having discussed the fundamentals of system design, we can now explore a practical example: the Airline Reservation System. This system will help illustrate the various components and design considerations involved. To better understand the Airline Reservation System, let's first examine its context-level flow diagram (DFD). In this diagram, key entities—Passenger, Travel Agent, and Airline—serve as the primary data sources and destinations.

System Design Example: Airline Reservation System
System Design Example: Airline Reservation System
Data Flow: The flow diagram illustrates how data moves through the system. For instance, when a Passenger wants to book a flight, they initiate a travel request, which is represented by an arrow pointing towards the system.
Interaction with Travel Agent and Airline: The request is then transmitted to two main entities: the Travel Agent and the Airline. The Travel Agent checks seat availability and preferences, sending an air flight request to the Airline.
Ticketing Process: If a seat is available, the Travel Agent proceeds to issue a ticket based on the Passenger's request. This interaction is captured in the flow diagram as the ticketing process.
Handling Unavailability: If no tickets are available, the system generates a request for Passenger Reservation, indicating that the Airline must manage and inform the Passenger about their reservation options.
This context-level flow diagram effectively encapsulates the interactions and data flow among the various components of the Airline Reservation System, providing a clear overview of how the system operates and how users engage with it.
