# 📘 System Design Overview

## 🔹 What is System Design?

System Design is the process of defining the architecture, components, modules, interfaces, and data for a system to satisfy specified requirements. It involves translating user requirements into a detailed blueprint that guides the implementation phase.

The goal is to create a well-organized and efficient structure that meets the intended purpose while considering factors like scalability, maintainability, and performance.

---

## 🎯 Objectives of System Design

- **Practicality**: Target the intended user base and design accordingly.
- **Accuracy**: Fulfill both functional and non-functional requirements.
- **Completeness**: Meet all user expectations and use cases.
- **Efficiency**: Optimize resource usage to reduce latency and cost.
- **Reliability**: Ensure minimal failure and high uptime.
- **Optimization**: Tune time and space complexity across components.
- **Scalability (Flexibility)**: Adapt to changing user needs over time.
- **Fault Tolerance**: Continue functioning even if one or more components fail.

---

## ✅ Advantages of System Design

- **Reduces Design Cost**: Reuse of patterns and components lowers effort.
- **Accelerates Development**: Frameworks and libraries speed up delivery.
- **Saves Time in SDLC**: Automation and structure reduce iteration cycles.
- **Improves Programmer Efficiency**: Familiar tools and standards reduce errors.
- **Conserves Resources**: Shared workflows prevent duplication.
- **Boosts Developer Creativity**: Encourages synergy across APIs, databases, and protocols.

---

## 🔄 System Design Life Cycle (SDLC)

The SDLC outlines the phases involved in designing and developing a system—software, hardware, or hybrid. It ensures the final product is reliable, scalable, and maintainable.

Phases typically include:
- Requirement Analysis
- System Architecture Design
- Component Design
- Implementation
- Testing
- Deployment
- Maintenance

---

## 🏗️ System Architecture

System Architecture defines how components are structured and deployed. It acts as the skeleton of a software system, laying out abstraction levels and integration points.

In simple terms, it’s the blueprint that aligns business logic with technical execution.

---

## 🧩 System Architecture Patterns

Architecture patterns are predefined ways to organize system components. Each solves specific design challenges.

### Types of Patterns

1. **Client-Server**: Clients request services; servers respond.
2. **Event-Driven**: Components communicate via events for responsiveness.
3. **Microkernel**: Core system with extensible plugins.
4. **Microservices**: Independent services that scale and deploy separately.

---

## 🧱 Modularity and Interfaces

### 1. Modularity
Breaks down systems into independent modules. Each module can be developed and tested separately, improving flexibility and maintainability.

### 2. Interfaces
Defines how users interact with the system—forms, navigation, reports. Good interfaces improve usability and data flow efficiency.

Together, modularity and interfaces create scalable and user-friendly systems.

---

## 📈 Evolution / Upgrade / Scaling of Systems

### 1. Vertical Scaling
Upgrade system specs (RAM, disk, CPU). Improves availability but may not address scalability limits.

### 2. Horizontal Scaling
Connect multiple systems to distribute load. Enhances fault tolerance and scalability.

---

## 🔄 How Data Flows Between Systems

**Data Flow Diagrams (DFDs)** visually represent how data moves through a system.

### DFD Components

| Symbol           | Meaning                                      |
|------------------|----------------------------------------------|
| Square           | Source or destination of data                |
| Arrow            | Data flow pipeline                           |
| Circle/Bubble    | Process transforming input to output         |
| Open Rectangle   | Data store or temporary repository           |

> **Note**: Use uppercase for sender/receiver labels in square boxes as per DFD conventions.

---

## ✈️ System Design Example: Airline Reservation System

### Context-Level Flow

- **Passenger** initiates a travel request.
- **Travel Agent** checks availability and sends a request to the **Airline**.
- If available, a ticket is issued.
- If unavailable, a reservation request is generated.

This flow illustrates how entities interact and how data moves through the system.

---

> 📎 _System Design is not just about structure—it's about creating resilient, scalable, and user-centric solutions._System Architecture Patterns
Modularity and Interfaces In System Design
Modularity and interfaces in systems design are essential concepts that enhance flexibility and usability by breaking down complex systems into manageable components and providing intuitive user interactions.

1. Modularity
Modular design involves breaking down complex products into smaller, independent components or modules. This allows each module (e.g., a car's engine or transmission) to be developed and tested separately, making the overall system more flexible and easier to manage. The final product is assembled by integrating these modules, enabling changes without affecting the entire system.

2. Interfaces
In systems design, interfaces are the points where users interact with the system. This includes navigation elements, data input forms, and report displays. Effective interfaces are intuitive and user-friendly, enhancing the overall user experience and ensuring efficient data collection and system navigation. Together, modularity and well-designed interfaces contribute to creating scalable, maintainable, and user-friendly systems.

Evolution/Upgrade/Scaling of an Existing System
With increasing tech usage, it’s crucial for developers to design scalable systems. If a system is not scalable, it is likely to crash with the increase in users. Hence the concept of scaling comes into effect. Suppose there is a system with configurations of specific disk and RAM which was handling tasks. Now if we need to evolve our system or scale up, we have two options with us.

1. Upgrade Specifications of existing system(Vertical Scaling):
We are simply improving the processor by upgrading the RAM and disk size and many other components. Note that here we are not caring about the scalability and availability of network bandwidth. Here as per evolution we are working over the availability factor only considering scalability will be maintained. This is known as vertical scaling.

2. Create a Distributed System by connecting multiple systems together(Horizontal Scaling):
Horizontal scaling involves connecting multiple systems together to scale up. This method allows for better scalability and fault tolerance by using multiple systems instead of upgrading individual components. In order to scale up, we need more systems (more chunks of blocks) and this is known as horizontal scaling.

Evolution/Upgrade/Scale of an Existing System
Evolution/Upgrade/Scale of an Existing System
How Data Flows Between Systems?
Data Flow Diagrams or DFDs is defined as a graphical representation of the flow of data through information. DFDs are designed to show how a system is divided into smaller portions and to highlight the flow of data between these parts. Below is an example to demonstrate the Data Flow Diagram's basic structure:

Basic-Structure-of-DFD
Basic Stucture of DFD
Components of DFD include:
Representation	Action performed
Square	Defines the source of destination of data
Arrow	Identifies data flow and acts as a pipeline throughwhich information flows
Circle/Bubble	Represents a process that transforms incoming data flow into outgoing data
Open Rectangle	It is a data store or data at rest/temporary repository of data
 Note:  Sender and Receiver should  be written in uppercase always. Rather it is good practrice to use uppercaswe letter what so ever is placed in square box as per DFD conventions. 

System Design Example: Airline Reservation System
Having discussed the fundamentals of system design, we can now explore a practical example: the Airline Reservation System. This system will help illustrate the various components and design considerations involved. To better understand the Airline Reservation System, let's first examine its context-level flow diagram (DFD). In this diagram, key entities—Passenger, Travel Agent, and Airline—serve as the primary data sources and destinations.

System Design Example: Airline Reservation System
System Design Example: Airline Reservation System
Data Flow: The flow diagram illustrates how data moves through the system. For instance, when a Passenger wants to book a flight, they initiate a travel request, which is represented by an arrow pointing towards the system.
Interaction with Travel Agent and Airline: The request is then transmitted to two main entities: the Travel Agent and the Airline. The Travel Agent checks seat availability and preferences, sending an air flight request to the Airline.
Ticketing Process: If a seat is available, the Travel Agent proceeds to issue a ticket based on the Passenger's request. This interaction is captured in the flow diagram as the ticketing process.
Handling Unavailability: If no tickets are available, the system generates a request for Passenger Reservation, indicating that the Airline must manage and inform the Passenger about their reservation options.
This context-level flow diagram effectively encapsulates the interactions and data flow among the various components of the Airline Reservation System, providing a clear overview of how the system operates and how users engage with it.



Absolutely, Siraj! Here's your complete content converted into a clean, structured Markdown (.md) file with full C# implementation of the parking lot system using object-oriented principles. This is perfect for GitHub documentation, interview prep, or team onboarding.

---

`md

🚗 Parking Lot Design Using Object-Oriented Principles in C#

🔹 Overview

Designing a parking lot using object-oriented principles involves modeling real-world entities like vehicles and parking spots as classes. This approach promotes modularity, reusability, and maintainability.

---

📌 Assumptions

- The parking lot has multiple levels, each with multiple rows of spots.
- It supports motorcycles, cars, and buses.
- Spot types: motorcycle, compact, and large.
- Motorcycle can park in any spot.
- Car can park in a compact or large spot.
- Bus requires five consecutive large spots in the same row.

---

🧱 Class Design

1. Enum: VehicleSize

`csharp
public enum VehicleSize {
    Motorcycle,
    Compact,
    Large
}
`

---

2. Abstract Class: Vehicle

`csharp
public abstract class Vehicle {
    public string LicensePlate { get; }
    public int SpotsNeeded { get; protected set; }
    public VehicleSize Size { get; protected set; }

    protected Vehicle(string licensePlate, VehicleSize size) {
        LicensePlate = licensePlate;
        Size = size;
        SpotsNeeded = (size == VehicleSize.Large) ? 5 : 1;
    }

    public abstract bool CanFitInSpot(ParkingSpot spot);
}
`

---

3. Concrete Vehicle Classes

🚌 Bus

`csharp
public class Bus : Vehicle {
    public Bus(string licensePlate) : base(licensePlate, VehicleSize.Large) { }

    public override bool CanFitInSpot(ParkingSpot spot) {
        return spot.SpotSize == VehicleSize.Large;
    }
}
`

🚗 Car

`csharp
public class Car : Vehicle {
    public Car(string licensePlate) : base(licensePlate, VehicleSize.Compact) { }

    public override bool CanFitInSpot(ParkingSpot spot) {
        return spot.SpotSize == VehicleSize.Compact || spot.SpotSize == VehicleSize.Large;
    }
}
`

🏍️ Motorcycle

`csharp
public class Motorcycle : Vehicle {
    public Motorcycle(string licensePlate) : base(licensePlate, VehicleSize.Motorcycle) { }

    public override bool CanFitInSpot(ParkingSpot spot) {
        return true;
    }
}
`

---

4. Class: ParkingSpot

`csharp
public class ParkingSpot {
    public Vehicle Vehicle { get; private set; }
    public VehicleSize SpotSize { get; }
    public int Row { get; }
    public int SpotNumber { get; }
    public Level Level { get; }

    public ParkingSpot(Level level, int row, int spotNumber, VehicleSize spotSize) {
        Level = level;
        Row = row;
        SpotNumber = spotNumber;
        SpotSize = spotSize;
    }

    public bool IsAvailable() => Vehicle == null;

    public bool CanFitVehicle(Vehicle vehicle) =>
        IsAvailable() && vehicle.CanFitInSpot(this);

    public void ParkVehicle(Vehicle vehicle) {
        if (CanFitVehicle(vehicle)) {
            Vehicle = vehicle;
        }
    }

    public void RemoveVehicle() {
        Vehicle = null;
    }
}
`

---

5. Class: Level

`csharp
public class Level {
    public int LevelNumber { get; }
    private ParkingSpot[] Spots;

    public Level(int levelNumber, int numSpots) {
        LevelNumber = levelNumber;
        Spots = new ParkingSpot[numSpots];
        // Initialize spots with dummy data
        for (int i = 0; i < numSpots; i++) {
            VehicleSize size = (i % 3 == 0) ? VehicleSize.Large :
                               (i % 3 == 1) ? VehicleSize.Compact :
                               VehicleSize.Motorcycle;
            Spots[i] = new ParkingSpot(this, i / 10, i, size);
        }
    }

    public bool ParkVehicle(Vehicle vehicle) {
        for (int i = 0; i < Spots.Length; i++) {
            if (vehicle is Bus) {
                if (CanParkBusAt(i)) {
                    for (int j = 0; j < vehicle.SpotsNeeded; j++) {
                        Spots[i + j].ParkVehicle(vehicle);
                    }
                    return true;
                }
            } else if (Spots[i].CanFitVehicle(vehicle)) {
                Spots[i].ParkVehicle(vehicle);
                return true;
            }
        }
        return false;
    }

    private bool CanParkBusAt(int index) {
        if (index + 4 >= Spots.Length) return false;
        for (int i = index; i < index + 5; i++) {
            if (!Spots[i].IsAvailable() || Spots[i].SpotSize != VehicleSize.Large)
                return false;
        }
        return true;
    }

    public bool RemoveVehicle(Vehicle vehicle) {
        bool removed = false;
        foreach (var spot in Spots) {
            if (spot.Vehicle == vehicle) {
                spot.RemoveVehicle();
                removed = true;
            }
        }
        return removed;
    }
}
`

---

6. Class: ParkingLot

`csharp
public class ParkingLot {
    private Level[] Levels;

    public ParkingLot(int numLevels, int numSpotsPerLevel) {
        Levels = new Level[numLevels];
        for (int i = 0; i < numLevels; i++) {
            Levels[i] = new Level(i, numSpotsPerLevel);
        }
    }

    public bool ParkVehicle(Vehicle vehicle) {
        foreach (var level in Levels) {
            if (level.ParkVehicle(vehicle)) return true;
        }
        return false;
    }

    public bool RemoveVehicle(Vehicle vehicle) {
        foreach (var level in Levels) {
            if (level.RemoveVehicle(vehicle)) return true;
        }
        return false;
    }
}
`

---

7. Class: Ticket

`csharp
public class Ticket {
    public Vehicle Vehicle { get; }
    public DateTime IssueTime { get; }
    public DateTime? ExitTime { get; private set; }

    public Ticket(Vehicle vehicle) {
        Vehicle = vehicle;
        IssueTime = DateTime.Now;
    }

    public void SetExitTime(DateTime exitTime) {
        ExitTime = exitTime;
    }

    public TimeSpan GetDuration() {
        return (ExitTime ?? DateTime.Now) - IssueTime;
    }
}
`

---

8. Class: PaymentService

`csharp
public class PaymentService {
    public double CalculateFee(Ticket ticket) {
        var duration = ticket.GetDuration();
        return Math.Ceiling(duration.TotalHours) * 1.0; // $1 per hour
    }

    public void ProcessPayment(Ticket ticket) {
        double fee = CalculateFee(ticket);
        Console.WriteLine($"Payment processed for ${fee:F2}");
    }
}
`

---

🧠 Design Principles Applied

- Single Responsibility Principle: Each class has one job.
- Encapsulation: Internal details are hidden.
- Polymorphism: CanFitInSpot() behaves differently per vehicle type.
- Separation of Concerns: Ticketing, payment, and parking are handled independently.

---

✅ Conclusion

This C# implementation of a parking lot system demonstrates how object-oriented principles can be used to build scalable, maintainable, and extensible software. The design supports multiple vehicle types, dynamic parking logic, and payment processing, and can be extended to include features like EV charging, dynamic pricing, or reservation systems.

`

---

Let me know if you'd like this exported as a downloadable .md file, or if you want to add UML diagrams, unit tests, or database integration next.

Great question 👍 Let’s break this down systematically because system design, system architecture, and high-level design (HLD) often overlap, but each has its own focus and aspects.


---

1. Aspects of System Design

System design is about how to build a system to meet requirements. It involves structuring components, interfaces, data, and interactions.

🔹 Key Aspects:

Requirements Analysis – functional and non-functional requirements.

Component Design – services, modules, subsystems, and their responsibilities.

Data Design – schema, storage model, caching strategies, indexing.

API & Interfaces – REST, gRPC, message queues, SDKs.

Scalability – horizontal vs vertical scaling, load balancing.

Availability & Reliability – replication, failover, retries, disaster recovery.

Performance & Latency – response time, throughput, bottlenecks.

Security – authentication, authorization, data encryption, secrets management.

Integration – with external systems, APIs, third-party services.

Maintainability & Extensibility – modularity, loose coupling, future-proofing.

Monitoring & Observability – logging, tracing, metrics, alerting.

Cost Efficiency – infra cost, licensing, optimization.



---

2. Aspects of System Architecture

System architecture is about the blueprint of the system — the structure and technology choices. It sets the foundation for system design.

🔹 Key Aspects:

Architecture Style – monolithic, layered, microservices, event-driven, serverless.

Technology Stack – languages, frameworks, databases, cloud services.

Deployment Architecture – on-premises, cloud (Azure/AWS/GCP), hybrid, edge.

Communication Model – synchronous (HTTP/gRPC) vs asynchronous (message bus, Kafka).

Data Flow & Processing – batch, streaming, real-time pipelines.

Scalability Strategy – sharding, partitioning, autoscaling.

Resilience Patterns – circuit breakers, bulkheads, retries, failover.

Security Architecture – IAM, zero-trust, firewalls, encryption at rest/in-transit.

Compliance & Governance – GDPR, HIPAA, ISO, data residency.

Infrastructure as Code – Terraform, Bicep, Ansible, Helm.

DevOps & CI/CD – automation, pipelines, release strategies (blue/green, canary).

Architecture Trade-offs – performance vs cost, consistency vs availability (CAP theorem).



---

3. Aspects of High-Level Design (HLD)

HLD sits between requirements and low-level design (LLD). It’s about creating an abstract view of the system to communicate with stakeholders (architects, devs, managers).

🔹 Key Aspects:

System Context Diagram – external users, systems, data flows.

Module Breakdown – main modules/services and their responsibilities.

Database Choices – SQL vs NoSQL, data partitioning, replication strategies.

API Contracts – endpoints, inputs/outputs, authentication.

Infrastructure Diagram – cloud/on-prem layout, regions, zones.

High-Level Sequence/Flow Diagrams – how requests flow through the system.

Non-Functional Aspects – performance, scalability, security considerations.

Integration Points – third-party APIs, legacy systems.

Error Handling & Recovery – timeouts, retries, fallbacks.

Technology Selection Justification – why a certain DB, cache, or framework.



---

Quick Differentiation

System Design → “How will the system be built?” (component-level design + trade-offs).

System Architecture → “What is the system’s structure and foundation?” (technology, styles, principles).

High-Level Design (HLD) → “How do we represent the system at a bird’s-eye view?” (diagrams, modules, interfaces).



---

👉 Would you like me to create a table comparing aspects of all three (System Design vs System Architecture vs HLD) for easier interview-style reference?




